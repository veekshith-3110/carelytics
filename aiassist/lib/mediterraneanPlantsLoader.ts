/**
 * Mediterranean Plants Dataset Loader
 * Loads and processes the Mediterranean plants dataset downloaded from Kaggle
 */

export interface MediterraneanPlant {
  name?: string
  scientific_name?: string
  common_name?: string
  family?: string
  description?: string
  uses?: string
  image_path?: string
  [key: string]: any // Allow additional fields from the dataset
}

let mediterraneanPlantsCache: MediterraneanPlant[] | null = null

/**
 * Load Mediterranean plants data from the processed JSON file
 * This file is generated by the download_dataset.py script
 */
export async function loadMediterraneanPlants(): Promise<MediterraneanPlant[]> {
  if (mediterraneanPlantsCache) {
    return mediterraneanPlantsCache
  }

  try {
    // In a Next.js app, we can fetch from the public folder or API route
    // For now, we'll try to load from the generated JSON file
    const response = await fetch('/api/mediterranean-plants')
    if (response.ok) {
      const data = await response.json()
      mediterraneanPlantsCache = data.plants || []
      return mediterraneanPlantsCache || []
    }
  } catch (error) {
    console.warn('Could not load Mediterranean plants from API, using fallback data', error)
  }

  // Fallback: return empty array if dataset not available
  // The dataset will be loaded when the Python script is run
  mediterraneanPlantsCache = []
  return []
}

/**
 * Search Mediterranean plants by name or scientific name
 */
export function searchMediterraneanPlants(
  query: string,
  plants: MediterraneanPlant[]
): MediterraneanPlant[] {
  if (!plants || plants.length === 0) return []
  
  const lowerQuery = query.toLowerCase().trim()
  
  return plants.filter(plant => {
    const name = (plant.name || 
                  plant.common_name || 
                  (plant as any).English_Name || 
                  '').toLowerCase()
    const scientificName = (plant.scientific_name || 
                           (plant as any).Scientific_Name || 
                           '').toLowerCase()
    const description = (plant.description || '').toLowerCase()
    const uses = (plant.uses || 
                  (plant as any).Folk_Uses || 
                  '').toLowerCase()
    
    return (
      name.includes(lowerQuery) ||
      scientificName.includes(lowerQuery) ||
      description.includes(lowerQuery) ||
      uses.includes(lowerQuery)
    )
  })
}

/**
 * Convert Mediterranean plant to MedicinalPlant format for compatibility
 */
export function convertToMedicinalPlant(
  plant: MediterraneanPlant,
  language: 'en' | 'kn' | 'ta' | 'te' | 'hi' = 'en'
): {
  name: string
  scientificName: string
  localNames: {
    en: string
    kn?: string
    ta?: string
    te?: string
    hi?: string
  }
  medicinalUses: string[]
  partsUsed: string[]
  benefits: string[]
  warnings: string[]
  isEdible: boolean
  confidence: number
} {
  // Handle CSV field names from the Mediterranean Plants dataset
  const name = plant.name || 
               plant.common_name || 
               (plant as any).English_Name || 
               'Unknown Plant'
  const scientificName = plant.scientific_name || 
                         (plant as any).Scientific_Name || 
                         ''
  const uses = plant.uses || 
               plant.description || 
               (plant as any).Folk_Uses || 
               ''
  const partUsed = (plant as any).Part_Used || ''
  const methodOfUse = (plant as any).Method_of_Use || ''
  
  // Parse uses into medicinal uses array
  let medicinalUses: string[] = []
  if (uses) {
    medicinalUses = uses
      .split(/[.,;]/)
      .map((u: string) => u.trim())
      .filter((u: string) => u.length > 0)
      .slice(0, 5)
  }
  
  if (medicinalUses.length === 0) {
    medicinalUses = ['Medicinal plant with traditional uses']
  }
  
  // Parse parts used
  const partsUsed = partUsed 
    ? partUsed.split(/[,\/]/).map((p: string) => p.trim()).filter((p: string) => p.length > 0)
    : ['Leaves', 'Flowers', 'Stem'] // Default
  
  // Determine if edible based on method of use
  const isEdible = methodOfUse && (
    methodOfUse.toLowerCase().includes('edible') ||
    methodOfUse.toLowerCase().includes('food') ||
    methodOfUse.toLowerCase().includes('tea') ||
    methodOfUse.toLowerCase().includes('infusion')
  ) ? true : false // Default to false for safety, unless explicitly edible
  
  return {
    name,
    scientificName,
    localNames: {
      en: name,
      // Could add Arabic name if available: ar: (plant as any).Arabic_Name
    },
    medicinalUses,
    partsUsed,
    benefits: medicinalUses,
    warnings: [
      'Consult with a healthcare provider before use',
      'Some plants may cause allergic reactions',
      methodOfUse ? `Method of use: ${methodOfUse}` : '',
    ].filter(w => w.length > 0),
    isEdible,
    confidence: 0.85,
  }
}

